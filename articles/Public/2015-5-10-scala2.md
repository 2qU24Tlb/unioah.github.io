title: "scala"
date: 2015-04-09 17:45:32
tags: scala
---


## Package:
- import one package:
  eg: package com.liftcode.stuff
- import all sub packages:
  eg: import scala.xml
- import selected packages:
  import scala.collection.immutable.{TreeMap, TreeSet}
- skip the scala prefix
  import math._
- rename import class
  import java.util.{HashMap => JavaHashMap}
- show the elapsed time for application
  only available if extends App
  $ scalac -Dscala.time 

## Identifiers:
- Alphanumeric:
- Operator:
  <- :range generator
  eg. a <- 1 to 10, a <- 1 until 10
  => :infered type
- Mixed:

## Variable Declation:
- var: mutable, can be changed.
  eg. var myVar : String = "Foo"
- val: immutable, can't be changed.
  eg. val myVar : String = "Foo"
- multiple vars:
  eg. val (myVar1: Int, myVar2: String) = Pair(40, "Foo")

## for loop with filter:
scala for loop allows to filter out some element using one or more if statements.
eg.
for( var x <- List
  if condition1; if condition2...
  ){
  statement(s);
}

## function:
def functionName ([list of parameters]) : [return type]

# Collections: [1]
Collections are containers. Those containers can be sequenced, linear sets like List, Tuple, Option, Map.
list: immutable, linked list. You cannot update it in place. There are mutable ordered sequence types as well, in scala.collection.mutable, such as Buffer types.[6]
- strict:
- laze: have elements that may not consume memory until they are accessed.

# {} contains a sequence of expressions and the result is also an expression.
# do not use chained assignments.
# input & output
print, println, printf
readInt, readDouble, readByte, readBoolean, readChar, readLine
# range:
1 to 10: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10
1 until 10: 1, 2, 3, 4, 5, 6, 7, 8, 9
# no break in Scala
    1. use a Boolean control variable
    2. use nested functions, return from the middle of a function
    3. break method in the Breaks object
# advance for loop
## nested for loop
for (i <- 1 to 3; j <- i to 3) println(i * 10 + j)
>>11 12 13 22 23 33

## filter
for (i <- 1 to 3; j <- 1 to 3 if i != j) println(i * 10 + j) 
>>12 13 21 23 31 32

## yield collection
for (i <- 1 to 10) yield i % 3
>> Yields Vector(1, 2, 0, 1, 2, 0, 1, 2, 0, 1)

# A method operates on an object, but a function doesn't.

# default arguments, named arguments
def decorate(str: String, Left: String = "[", right: String = "]") = left + str + right
named arguments need not be in the same order as the parameters. 

# Variable Arguments
def sum (args: Int*) = {
var result = 0
for (arg <- args) result += args
result
}

>> val s = sum(1, 4, 9, 16, 25)
>> val s = sum(1 to 5: _*)

# procedure: a function that returns no value(without =) 
# lazy value
>> lazy val words = fromFile...
every time a lazy value is accessed, a method is called, whether the value has already been initialized.

# Array
use an Array if the length is fixed and an ArrayBuffer if the length can vary
use () to access elements
use for (i <- 0 until a.length) to traverse the elements
use for (elem <- arr if ..) .. yield ... to transform into a new array

# Map
## construct a mutable Map
val scores = scala.collection.mutable.Map[String, Int]()
+= ("Alice" -> 10)
val AliceScore = scores("Alice")
scores.contains("Bob")

# Tuple
aggregates of values of different types.
val t = (1, "2", True)
access its components with the methods _1, _2, _3, etc.
t._1
** component positions of a tuple start with 1, not 0 **

# Zipping
bundle together values so that they can be processed together.
val symbols = Array("<", "-", ">")
val counts = Array(2, 10, 2)
val pairs = symbols.zip(counts)
>> Array(("<", 2), ("-", 10), (">", 2))

# use () for a mutator method (a method that changes the object state)
# drop () for an accessor method (a method that does not change the object state)

# Class
Class Person {
    var age = 0
    }
    val fred = new Person
Getter:
    fred.age
Setter:
    fred.age_=(21)
** Object Private: a method can access the private fields of all objects of its class. **
Auxiliary Constructor:
    Each auxiliary constructor must start with a call to a previously defined auxiliary constructor or the primary constructor.
    def this(name: String) {
    this()
    this.name = name
    }

The Primary Constructor:

# Object
use it when you need a class with a single instance.
like static methods or fields in other languages.
You cannot provide constructor parameters for object.

# Packages:
There is no enforce relationship between the directory of the source file and the package.



# References:
[1] http://www.tutorialspoint.com/scala/scala_collections.htm
[2] http://www.scala-lang.org/old/node/166
[3] http://davidb.github.io/scala-maven-plugin/index.html
[4] http://www.scala-lang.org/old/node/345
[5] http://www.artima.com/pins1ed/a-scalable-language.html
[6] http://stackoverflow.com/questions/5094314/how-to-replace-a-given-item-in-a-list
